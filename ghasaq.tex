\documentclass[twocolumn,hidelinks]{article}
\usepackage{orcidlink}
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={4.0},
]{doclicense}
\usepackage[margin=1in,columnsep=1em]{geometry}
\usepackage{enumitem} % to control gaps in description lists
\usepackage{url}
\usepackage[acronym]{glossaries}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{complexity}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{cancel}
\newcommand{\ghasaq}{Ġasaq}
\newcommand{\baheem}{Băhēm}
\DeclareMathOperator{\random}{random}
\DeclareMathOperator{\enc}{enc}
\DeclareMathOperator{\dec}{dec}
\DeclareMathOperator{\fread}{read}
\DeclareMathOperator{\fwrite}{write}
\DeclareMathOperator{\entropy}{H}
\makeglossaries
\newacronym{trng}{TRNG}{true random number generator}
\newacronym{otp}{OTP}{one-time pad}
\newacronym{pbkdf}{PBKDF}{Password-Based Key Derivation Function}
\newacronym{xor}{XOR}{bitwise exclusive-or operation}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\renewcommand\qedsymbol{$\blacksquare$}
\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}
\usepackage{cleveref} % must be loaded last
\begin{document}

\begin{center}
    \Huge
    \ghasaq\\
    \Large
    Provably Secure Key Derivation\\
    \normalsize
    \vspace{0.5em}
    M. Rajululkahf\,\orcidlink{0000-0001-9061-2921}\footnote{Author's
    e-mail address: \{last name\}\url{@pm.me}}\\
    \vspace{0.5em}
    \footnotesize
    \today\\
\end{center}

\section*{Overview}
This paper proposes \ghasaq; a provably secure key derivation method that,
when given access to a \gls{trng}, allows communicating parties, that have
a pre-shared secret password $\mathbf{p}$, to agree on a secret key
$\mathbf{k}$ that is indistinguishable from truly random numbers with a
guaranteed entropy of $\min(\entropy(\mathbf{p}), |\mathbf{k}|)$.

\ghasaq's security guarantees hold even in a post-quantum world under
Grover's algorithm \cite{10.1145/237814.237866}, or even if it turns out
that $\P = \NP$ \cite{10.1145/800157.805047}. Such strong security
guarantees, that are similar to those of the \gls{otp}, became attractive
after the introduction of \baheem\ \cite{baheem}; a similarly provably
secure symmetric cipher that is strong enough to shift cipher's security
bottleneck to the key derivation function.

State of art key derivation functions such as the \gls{pbkdf}
\cite{rfc8018}, or even memory-hard variants such as Argon2 \cite{argon2},
are not provably secure, but rather not fully broken yet.  They do not
guarantee against needlessly losing password entropies; that is, the output
key could have an entropy lower than password's entropy, even if such
entropy is less than key's bit length. In addition to assuming that $\P \ne
\NP$, and, even then, getting their key space square-rooted under Grover's
algorithm ---none of which are limitations of \ghasaq.

Using such key derivation functions, as the \gls{pbkdf} or Argon2, is
acceptable with conventional ciphers, such as ChaCha20 \cite{chacha20} or
AES \cite{aes}, as they, too, suffer the same limitations, hence none of
them are bottlenecks for the other.  Similarly to how a glass door is not a
security bottleneck for a glass house.

However, a question is:  why would a people secure their belongings in a
glass made structure, to justify a glass door, when they can use a
re-enforced steel structure at a similar cost?  This is where \ghasaq\
comes to offer \baheem\ the re-enforced steel door that matches its
security.

\blfootnote{\vspace{-1em}\doclicenseThis}
\vfill
\break

\section*{Notation}
\begin{description}[itemsep=0em]
    \item[$\random(n) = (r_0, r_1, \ldots, r_n)$:]  A sequence of $n$ many
        random bits generated by a \gls{trng}.
    \item[$\mathbf{x} = (x_0, x_1, \ldots, x_{|\mathbf{x}|-1})$:]  A tuple
        of $|\mathbf{x}|$ many bits.
    \item[$\entropy(\mathbf{x})$:]  Shannon's entropy of random variable
        $\mathbf{x}$.
    \item[$\mathbf{x} \oplus \mathbf{y}$:]  Bitwise exclusive-or operation
        between two variables.
    \item[$\mathbf{p} = (p_0, p_1, \ldots, p_{|\mathbf{p}|-1})$:]  An
        arbitrarily long pre-shared secret password of $|\mathbf{p}|$ many
        bits.  Since passwords are typed by humans, they often contain
        redundancies, hence $\entropy(\mathbf{p}) \le |\mathbf{p}|$.
    \item[$\mathbf{k} = (k_0, k_1, \ldots, k_{|\mathbf{k}|-1})$:]  A
        secret key derived based on $\mathbf{p}$.
    \item[$\mathbf{q}_i = (p_i, p_i, \ldots)$:]  A tuple containing the
        $i^{\text{th}}$ bit of password $\mathbf{p}$ repeated
        $|\mathbf{k}|$ many times.  In other words,
        $|\mathbf{q}_i|=|\mathbf{k}|$ and $\entropy(\mathbf{q}_i) =
        \entropy(p_i) \le 1$.
    \item[$\mathbf{r}_i = \random(|\mathbf{k}|)$:]  A uniformly distributed
        $|\mathbf{k}|$ bits random umber.  There are $\mathbf{r}_0,
        \mathbf{r}_1, \ldots, \mathbf{r}_{|\mathbf{p}| - 1}$ of such random
        numbers.
    \item[$\mathbf{\hat r}_i$:]  Encrypted form of $\mathbf{r}_i$ that is
        shared publically.
    \item[$\min(n, m)$:]
        \[\begin{cases}
            n & \text{if } n < m\\
            m & \text{otherwise}\\
        \end{cases}\]
\end{description}

\tableofcontents
\break

\section{Background}
In a previous private meeting between Alice and Bob, they concluded to use
a \gls{trng} to generate $128$ random bits, and to use them as their
pre-shared secret key.  They also agreed to use the \baheem\ symmetric
cipher \cite{baheem}.  Further details about this previous meeting can be
found in the background section in \cite{baheem}.

However, since then, Alice and Bob found that they are unable to memorise
those $128$ true random bits, not even with mnemonic encodings.
Practically, this made them write the $128$ bits in some form of storage,
and carried the storage with them.

While carrying the $128$ bits in a small storage device is much more
manageable than carrying terabytes worth of random one-time pad, it was
still not ideal for Alice and Bob.

Their main reasoning is that, if they were to be captured by an adversary,
and found to poses the $128$ random bits, then their attempts to deny their
ownership of encrypted data might become harder.  Specially if the
adversary found that the $128$ bits decrypt some files that they possess.
They also had secondary reasons, such as the inconvenience that is
associated with backup recovery plans should the device be lost.

However, because of the past memories of Alice and Bob, they could easily
memorise odd sentences like:
\begin{quote}
    ``\emph{The anteater ate steel with his cosmic buddy; the turbo-charged
    flying octopus}''
\end{quote}

While Alice and Bob could not calculate the entropy of that sentence, as
they lack knowledge about the probabilistic language model inside their own
heads, they were nonetheless highly confident that such a phrase has ``high
enough'' entropy for their purpose, specially if it allows them to get rid
of the constraint of carrying a password storage device with them.

However, they found that today's state-of-art key derivation methods, such
as \gls{pbkdf} \cite{rfc8018}, or even memory-hard variants such as Argon2
\cite{argon2}, are not provably secure; that is, there might be some
cryptanalysis techniques that could possibly reduce the entropy of their
derived keys.  This bothered them, as using a non-proven key derivation
function might serve as the Achilles' heel in their provably secure
\baheem\ cipher.

\ghasaq, the key derivation method that is proposed in this paper, solves
the Alice and Bob problem above, by offering a provably secure key
derivation method similar to that of the \gls{otp}, or \baheem, that is
independent to whether quantum computers were used, or to whether it turned
out that $\P = \NP$.

\section{Proposed Algorithm:  \ghasaq}

\begin{algorithm}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \Input{$\mathbf{p}, |\mathbf{k}|$}
    \Output{$
        \mathbf{\hat r}_0, \mathbf{\hat r}_1, \ldots,
        \mathbf{\hat r}_{|\mathbf{p}|-1}, \mathbf{k}
    $}
    \hrulefill\\
    $\mathbf{k} \gets (0, 0, \ldots)$ a tuple of $|\mathbf{k}|$ many
    zeros\\
    \For{$i \in \{0, 1, \ldots,|\mathbf{p}|-1\}$}{
        $\mathbf{r}_i \gets \random(|\mathbf{k}|)$\\
        $\mathbf{q}_i \gets (p_i, p_i, \ldots)$, where $|\mathbf{q}_i| =
        |\mathbf{k}|$\\
        $\mathbf{k} \gets \mathbf{k} \oplus \mathbf{r}_i$\\
        $\mathbf{\hat r}_i \gets \mathbf{r}_i \oplus \mathbf{q}_i$\\
    }
    \Return{$
        \mathbf{\hat r}_0, \mathbf{\hat r}_1,
        \ldots, \mathbf{\hat r}_{|\mathbf{p}|-1}, \mathbf{k}
    $}

    \caption{\ghasaq\ key creation}
    \label{alg_ghasaq_create}
\end{algorithm}

\begin{algorithm}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \Input{$
        \mathbf{p}, \mathbf{\hat r}_0, \mathbf{\hat r}_1, \ldots,
        \mathbf{\hat r}_{|\mathbf{p}|-1}
    $}
    \Output{$\mathbf{k}$}
    \hrulefill\\
    $\mathbf{k} \gets (0, 0, \ldots)$ a tuple of $|\mathbf{k}|$ many
    zeros\\
    \For{$i \in \{0, 1, \ldots,|\mathbf{p}|-1\}$}{
        $\mathbf{q}_i \gets (p_i, p_i, \ldots)$, where $|\mathbf{q}_i| =
        |\mathbf{k}|$\\
        $\mathbf{r}_i \gets \mathbf{\hat r}_i \oplus \mathbf{q}_i$\\
        $\mathbf{k} \gets \mathbf{k} \oplus \mathbf{r}_i$\\
    }
    \Return{$\mathbf{k}$}

    \caption{\ghasaq\ key retrieval}
    \label{alg_ghasaq_retrieve}
\end{algorithm}

The key derivation in \ghasaq\ is in two parts:
\begin{description}
    \item[Creation.]  At first, a key $\mathbf{k}$ is defined from the
        input password $\mathbf{p}$ and a one-time pad of secret random
        numbers $\mathbf{r}_0, \mathbf{r}_1, \ldots,
        \mathbf{r}_{|\mathbf{k}|-1}$. A corresponding public sequence
        $\mathbf{\hat r}_0, \mathbf{\hat r}_1, \ldots, \mathbf{\hat
        r}_{|\mathbf{k}|-1}$ is also created and shared publicly to allow
        for retrieving the key $\mathbf{k}$ later by the communicating
        parties that know the pre-shared secret password $\mathbf{p}$.
        The key $\mathbf{k}$ itself is not transmitted, but rather found
        indirectly during the retrieval process.

        Key creation is shown in \Cref{alg_ghasaq_create}.
        \Cref{sec_c_examples} shows an example implementation in the C
        programming language.
    \item[Retrieval.]  Using a public sequence $\mathbf{\hat r}_0,
        \mathbf{\hat r}_1, \ldots, \mathbf{\hat r}_{|\mathbf{k}|-1}$ and
        its corresponding pre-shared secret password $\mathbf{p}$, its
        corresponding private sequence $\mathbf{r}_0, \mathbf{r}_1, \ldots,
        \mathbf{r}_{|\mathbf{k}|-1}$ is retrieved, which is then used to
        define the secret key $\mathbf{k}$.

        Key retrieval is shown in \Cref{alg_ghasaq_retrieve}.
        \Cref{sec_c_examples} shows an example implementation in the C
        programming language.
\end{description}

In other words, if Alice wants to send Bob an encrypted message by a key
that is derived securely from their pre-shared secret password, she will
first send him $\mathbf{\hat r}_0, \mathbf{\hat r}_1, \ldots, \mathbf{\hat
r}_{|\mathbf{p}|-1}$ in order to let him securely retrieve of the key, for
as long as he knows the pre-shared secret password $\mathbf{p}$. This key
can then be used with a provably secure symmetric cipher, such s \baheem\
\cite{baheem}, to encrypt their future messages.

The sequence $\mathbf{\hat r}_0, \mathbf{\hat r}_1, \ldots, \mathbf{\hat
r}_{|\mathbf{p}|-1}$ is shareable publicly.  That is, Eve seeing it will
not reveal to her her any information about the password. Yet, the sequence
allows Alice and Bob to mutually agree on a perfectly secure key
$\mathbf{k}$ based on their pre-shared password $\mathbf{p}$.

Alice and Bob do not have to exchange the public sequence $\mathbf{\hat
r}_0, \mathbf{\hat r}_1, \ldots, \mathbf{\hat r}_{|\mathbf{p}|-1}$ every
time they communicate, as they can simply cache the key $\mathbf{k}$ and
re-use it for future communications. They will have to repeat the
creation-retrieval process again only if they lose the key, or change their
password.

\section{Security Proof}
\begin{definition}
    A key derivation system is \emph{perfectly secure} if it simultaneously
    satisfies the following:
    \begin{description}[itemsep=0em]
        \item[Safe public output:]  Knowledge about the public output
            $\mathbf{\hat r}_0, \mathbf{\hat r}_1, \ldots, \mathbf{\hat
            r}_{|\mathbf{p}|-1}$ must not reveal information about
            the password $\mathbf{p}$ or the derived key $\mathbf{k}$.
            \begin{align*}
                \entropy(\mathbf{p} | \mathbf{\hat r}_0, \mathbf{\hat r}_1,
                \ldots, \mathbf{\hat r}_{|\mathbf{p}|-1}) &=
                \entropy(\mathbf{p}) \\
                \entropy(\mathbf{k} | \mathbf{\hat r}_0, \mathbf{\hat r}_1,
                \ldots, \mathbf{\hat r}_{|\mathbf{p}|-1}) &=
                \min(\entropy(\mathbf{p}), |\mathbf{k}|)
            \end{align*}
        \item[Maximum key entropy:]  Entropy of the derived key
            $\mathbf{k}$ must equate the entropy of the password
            $\mathbf{p}$, or the number of key bits $|\mathbf{k}|$,
            whichever is smaller.
            \[
                \entropy(\mathbf{k}) \
                    = \min(\entropy(\mathbf{p}), |\mathbf{k}|)
            \]
        \item[Random-looking key:]  The distribution of bits in
            $\mathbf{k}$ must be indistinguishable from that of a
            $|\mathbf{k}|$ many bits of a true random number
            $\random(|\mathbf{k}|)$.
    \end{description}
\end{definition}

\subsection{Safe Public Output}
\begin{proof}
    By the definition of \ghasaq, for any password bit $i \in \{0, 1,
    \ldots, |\mathbf{p}|-1\}$, $\mathbf{\hat r}_i$ can be viewed as the
    ciphertext of the \gls{xor} cryptosystem $\mathbf{\hat r}_i \gets
    \mathbf{r}_i \oplus \mathbf{q}_i$ where a true random number
    $\mathbf{r}_i$ is encrypted by $\mathbf{q}_i$, which is an
    $|\mathbf{k}|$ many bits repetition of the $i^{\text{th}}$ bit of the
    password $\mathbf{p}$.

    Based on the properties of the \gls{xor} cryptosystem, which is
    described in \Cref{sec_xor_cryptosystem_review}, it follows that, an
    adversary that observes the public outputs $\mathbf{\hat r}_0, \mathbf{\hat
    r}_1, \ldots, \mathbf{\hat r}_{|\mathbf{p}|-1}$, will not be able to
    gain any information about the password $\mathbf{p}$. In other words,
    $\entropy(\mathbf{p} | \mathbf{\hat r}_0, \mathbf{\hat r}_1, \ldots,
    \mathbf{\hat r}_{|\mathbf{p}|-1}) = \entropy(\mathbf{p})$ is guaranteed
    by the properties of the \gls{xor} cryptosystem.

    Additionally, since the key $\mathbf{k}$ is defined by \gls{xor}ing the
    cleartext random numbers $\mathbf{r}_0, \mathbf{r}_2, \ldots,
    \mathbf{r}_\mathbf{|\mathbf{p}|-1}$, and since information about the
    password $\mathbf{p}$ is required in order to retrieve those cleartext
    random numbers from the public output $\mathbf{\hat r}_0, \mathbf{\hat
    r}_2, \ldots, \mathbf{\hat r}_\mathbf{|\mathbf{p}|-1}$, it follows that
    knowing the public output does not reduce key's entropy below
    $\min(\entropy(\mathbf{p}), |\mathbf{k}|)$.
\end{proof}

\begin{theorem}
    \ghasaq\ has safe public output.
\end{theorem}

\subsection{Maximum Key Entropy}
\begin{proof}
    Since:
    \begin{itemize}
        \item $\mathbf{r}_i$ is a true $|\mathbf{k}|$ many bits random
            number by definition, each of which is guaranteed to satisfy
            $\entropy(\mathbf{r}_i) = \entropy(p_i)$ even when the public
            output $\mathbf{\hat r}_i$ is revealed, as explained in
            \Cref{sec_xor_cryptosystem_review}.
        \item $\mathbf{k}$ is the result of \gls{xor}ing $|\mathbf{p}|$
            many such random numbers.
        \item $|\mathbf{k}|$ is usually large enough, such as $128$ bits,
            to have near-zero probability of collisions between the
            $\mathbf{r}_i$ true numbers.

            For example, in order to have birthday collision probability of
            $10^{-18}$ with $128$ bit random numbers, one would have to
            generate $2.6 \times 10^{10}$ many such $128$ random bits
            \cite{birthdayattack}. Practically, it is trivial to set
            $|\mathbf{k}|$ to be large enough so that such birthday
            collisions never happen in practice, while still retaining a
            usable cryptographic system.
    \end{itemize}
    Then it follows that:
    \[
        \entropy(\mathbf{k})
        = \begin{cases}
            \entropy(p_0) + \entropy(p_1) + \ldots & \text{if }
            \entropy(\mathbf{p}) < |\mathbf{k}| - \epsilon\\
            |\mathbf{k}| - \epsilon & \text{otherwise}\\
        \end{cases}
    \]
    where $\epsilon$ is information loss due to the collisions that may
    arise between $|\mathbf{p}|$ many $|\mathbf{k}|$ long random bits.
    Since $|\mathbf{k}|$ is usually large enough, $\epsilon \approx 0$.
\end{proof}

\begin{theorem}
    \ghasaq\ has maximum key entropy.
\end{theorem}

\subsection{Random-looking Key}
\begin{proof}
    Since the key $\mathbf{k}$ is defined by \gls{xor}ing true random
    numbers $\mathbf{r}_0, \mathbf{r}_1, \ldots, ,
    \mathbf{r}_{|\mathbf{p}|-1}$, it follows by the properties of the
    \gls{xor} cryptosystem that $\mathbf{k}$ is indistinguishable from a
    true random number.
\end{proof}

\begin{theorem}
    \ghasaq's keys are indistinguishable from true random numbers.
\end{theorem}

\section{Implementation Example}

\subsection{An Early Prototype:  Alyal}
Alyal is an early single-threaded prototype implementation for securely
encrypting files.  It uses \ghasaq\ to derive keys, which are then used to
encrypt and decrypt files by the \baheem\ cipher.

Alyal assumes that $|\mathbf{k}| = 128$ bits, and attaches the public
random bits $\mathbf{\hat r}_0, \mathbf{\hat r}_1, \ldots, \mathbf{\hat
r}_{|\mathbf{p}|-1}$ along the ciphertext of every file that it encrypts.
Because of \ghasaq's and \baheem's provable security that is very similar
to that of the \gls{otp}, $|\mathbf{k}| = 128$ is more than enough, even
for a post-quantum world, or even if $\P = \NP$.

\subsubsection{Installation and Usage}
\begin{verbatim}
> git clone \
    https://codeberg.org/rajululkahf/alyal
> cd alyal
> make
> dd bs=1MB count=500 \
    if=/dev/zero of=test.txt
> ./alyal dkenc test.txt test.enc
> ./alyal dkdec test.enc test.enc.txt
> shasum *
\end{verbatim}

\subsubsection{Benchmark}
\Cref{tbl_benchmark} shows an early benchmark that was performed on a
machine with a 3.4GHz Intel Core i5-3570K CPU, 32GB RAM, 7200 RPM hard
disks and Linux 5.17.1-gentoo-x86-64.

\begin{table}[tbh]
    \centering
    \begin{tabular}{rccr}
                & Alyal     & Alyal        & \\
                & Raw key   & \ghasaq\ key & Difference\\\hline
        Encrypt & 3.84 secs & 3.95 secs    & -0.11 secs\\
        500MB   & 4.29 secs & 4.40 secs    & -0.11 secs\\
                & 4.23 secs & 4.34 secs    & -0.10 secs\\\hline
        Decrypt & 0.66 secs & 0.67 secs    & -0.01 secs\\
        500MB   & 0.82 secs & 0.82 secs    &  0.00 secs\\
                & 0.82 secs & 0.83 secs    & -0.01 secs\\
    \end{tabular}
    \caption{Wall-clock run-time comparison between Alyal's repeated file
    encryptions.  \emph{Raw key} is when Alyal was given a $128$ bit key
    directly.  \emph{\ghasaq} is when \ghasaq\ was used to derive a key
    from a password.} \label{tbl_benchmark}
\end{table}

\Cref{tbl_benchmark} shows that \ghasaq's key creation and retrieval
overhead is negligible for most applications, even without caching.

\section{Conclusion}
This paper presented \ghasaq, a provably secure key derivation that
guarantees that no cryptanalysis can degrade its security below
$\min(\entropy(\mathbf{p}), |\mathbf{k}|)$ many entropy bits with
properties identical to that of the \gls{otp}, and a negligible overhead
for most applications.  If \ghasaq's output is cached, then it has no
overhead.

An early implementation of \ghasaq\ is also released alongside this paper
to demonstrate its applicability for real world scenarios, even when
\ghasaq's output is not cached.

Future work can research provably-secure memory-hard variations of
\ghasaq-based key derivation methods.

\bibliographystyle{unsrt}
\bibliography{references}

\vfill
\break
\appendix
\section{XOR Cryptosystem Review}\label{sec_xor_cryptosystem_review}
Since \ghasaq\ makes frequent use of the \gls{xor} cryptosystem, it makes
sense to introduce some of its properties first.

Let $(x,r) \in \{0,1\}^2$ be a pair of independent random variables, with
$\Pr(r=0)=2^{-1}$, used in the cryptosystem $\hat x \gets x \oplus r$,
where $\hat x$ is the ciphertext.

If the adversary finds the public information that $\hat x = 0$, then she
can conclude that $x=r$ and deduce the following about the probability
$\Pr(x=0 | x=r)$:
\[\begin{split}
    &= \frac{\Pr(x=0)\Pr(x=r | x=0)}{\Pr(x=r)} \\
    &= \frac{
        \Pr(x=0)\Pr(r=0)
       }{
        \Pr(x=0)\Pr(r=0) + \Pr(x=1)\Pr(r=1)
       } \\
    &= \frac{
        \Pr(x=0)\cancel{2^{-1}}
       }{
        \Pr(x=0)\cancel{2^{-1}} + \Pr(x=1)\cancel{2^{-1}}
       } \\
    &= \frac{\Pr(x=0)}{\Pr(x=0) + \Pr(x=1)} \\
    &= \frac{
        \Pr(x=0)
       }{
           \cancel{\Pr(x=0)} + (1 - \cancel{\Pr(x=0)})
       } \\
    &= \Pr(x=0)
\end{split}\]

Likewise, the following can be deduced about the probability $\Pr(r=0 |
x=r)$:
\[\begin{split}
    &= \frac{\Pr(r=0)\Pr(x=r | r=0)}{\Pr(x=r)} \\
    &= \frac{
        \Pr(r=0)\Pr(x=0)
       }{
        \Pr(x=0)\Pr(r=0) + \Pr(x=1)\Pr(r=1)
       } \\
    &= \frac{
        \cancel{2^{-1}}\Pr(x=0)
       }{
        \Pr(x=0)\cancel{2^{-1}} + \Pr(x=1)\cancel{2^{-1}}
       } \\
    &= \frac{\Pr(x=0)}{\Pr(x=0) + \Pr(x=1)} \\
    &= \frac{
        \Pr(x=0)
       }{
           \cancel{\Pr(x=0)} + (1 - \cancel{\Pr(x=0)})
       } \\
    &= \Pr(x=0)
\end{split}\]

The same also applies if $\hat x = 1$, by which $\Pr(x=0 | x \ne r) =
\Pr(r=0 | x \ne r) = \Pr(x=0)$.

If $r$ was the encryption key, and $x$ was the cleartext, then $\Pr(x=0 |
x=r) = \Pr(x=0)$ implies that the cryptosystem system has perfect secrecy,
as the adversary gains no information about the cleartext by knowing
the ciphertext $\hat x$.  This can be expressed by using the information
gain measure:
\[\begin{split}
    & IG(x|\hat x = 0) \\
    &\quad= \entropy(x) - \entropy(x|\hat x = 0)\\
    &\quad= \left(\begin{split}
          & \Pr(x=0)\log_2(\Pr(x=0)^{-1})\\
        + & (1-\Pr(x=0))\log_2((1-\Pr(x=0))^{-1})\\
        - & \Pr(x=0)\log_2(\Pr(x=0)^{-1})\\
        - & (1-\Pr(x=0))\log_2((1-\Pr(x=0))^{-1})\\
    \end{split}\right)\\
    &\quad= 0
\end{split}\]

On the other hand, if $x$ was the encryption key, and $r$ was the
cleartext, then $\Pr(r=0 | x=r) = \Pr(x=0)$ implies that the cryptosystem
system does not have perfect secrecy, as the adversary is able to gain
information about the cleartext by knowing the ciphertext $\hat x$. The
following quantifies the number of information bits that the adversary
gains about the cleartext in this scenario from the ciphertext:
\[\begin{split}
    & IG(r|\hat x = 0) \\
    &\quad= \entropy(r) - \entropy(r|\hat x = 0)\\
    &\quad= \left(\begin{split}
        & 2^{-1}\log_2(2)\\
        + & (1-2^{-1})\log_2((1-2^{-1})^{-1})\\
        - & \Pr(x=0)\log_2(\Pr(x=0)^{-1})\\
        - & (1-\Pr(x=0))\log_2((1-\Pr(x=0))^{-1})\\
    \end{split}\right)\\
    &\quad= \left(\begin{split}
        & 1\\
        - & \Pr(x=0)\log_2(\Pr(x=0)^{-1})\\
        - & (1-\Pr(x=0))\log_2((1-\Pr(x=0))^{-1})\\
    \end{split}\right)\\
    &\quad= 1 - \entropy(x)
\end{split}\]

In other words, $IG(r|\hat x = 0) = 1 - \entropy(x)$ means that the
information about $x$ is preserved, and everything else is lost to the
adversary.  This also implies that $\entropy(r) = \entropy(x)$.

For any $i \in \{0, 1, \ldots, |\mathbf{p}|-1\}$, the reason behind
\ghasaq's use of the cryptosystem $\mathbf{\hat r}_i \gets \mathbf{r}_i
\oplus \mathbf{q}_i$ is not to preserve all information about
$\mathbf{r}_i$, but rather to ensure that $\entropy(\mathbf{r}_i) =
\entropy(\mathbf{q}_i) = \entropy(p_i)$, while having $\mathbf{r}_i$ look
indistinguishable from any $|\mathbf{k}|$ many bits number that is
generated from a \gls{trng}.

\vfill
\break
\section{Examples in C}\label{sec_c_examples}
The following is a \ghasaq\ key creation example in C.  \emph{This is an
example to aid in explaining \Cref{alg_ghasaq_create}; not fit for
production}.

\begin{verbatim}
void ghasaq_make_key(
  char *p,     /* password input        */
  FILE *trng,  /* TRNG stream input     */
  FILE *ret,   /* retrieval bits output */
  uint64_t *k, /* 128-bit key output    */
) {
  k[0] = 0;
  k[1] = 0;
  int i, j;
  uint64_t r[2];
  for (i = 0; p[i] != '\n'; i++) {
    for (i = 1; i <= 128; i <<= 1) {
      fread(r, 16, 1, trng);
      k[0] ^= r[0];
      k[1] ^= r[1];
      if (p[i] & i) {
        r[0] ^= 0xffffffffffffffff;
        r[1] ^= 0xffffffffffffffff;
      }
      fwrite(r, 16, 1, ret);
    }
  }
}
\end{verbatim}

The following is a key retrieval example in C.  \emph{This is an example to
aid in explaining \Cref{alg_ghasaq_retrieve}; not fit for production}.

\begin{verbatim}
void ghasaq_get_key(
  char *p,     /* password input       */
  FILE *ret,   /* retrieval bits input */
  uint64_t *k, /* 128-bit key output   */
) {
  k[0] = 0;
  k[1] = 0;
  int i, j;
  uint64_t r[2];
  for (i = 0; p[i] != '\n'; i++) {
    for (i = 1; i <= 128; i <<= 1) {
      fread(r, 16, 1, ret);
      if (p[i] & i) {
        r[0] ^= 0xffffffffffffffff;
        r[1] ^= 0xffffffffffffffff;
      }
      k[0] ^= r[0];
      k[1] ^= r[1];
    }
  }
}
\end{verbatim}

\end{document}
